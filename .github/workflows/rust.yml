name: Build and Release

# This workflow has different behaviors based on the trigger:
# - On PRs: Build and verify all targets (no release)
# - On pushes to main: Build and verify all targets (no release) 
# - On tags starting with 'v': Build all targets AND create GitHub release
# - On manual dispatch: Build and verify all targets (no release)

# Trigger the workflow on multiple events
on:
  # Run on pushes to main branch
  push:
    branches:
      - main
    # Also run on tag creation (for releases)
    tags:
      - 'v*'
  # Run on pull requests to main
  pull_request:
    branches:
      - main
  # Allow manual triggering
  workflow_dispatch:

# Set environment variables for consistent usage across jobs
env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Job to determine version for consistent versioning across build types
  version:
    name: Determine Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      is_release: ${{ steps.version.outputs.is_release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine version and build type
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            # This is a tag build - extract version from tag
            TAG_VERSION=${GITHUB_REF#refs/tags/v}
            echo "version=${TAG_VERSION}" >> $GITHUB_OUTPUT
            echo "tag=v${TAG_VERSION}" >> $GITHUB_OUTPUT
            echo "is_release=true" >> $GITHUB_OUTPUT
            echo "Release build - Version: ${TAG_VERSION}"
          else
            # This is a regular build - use Cargo.toml version + commit SHA
            CARGO_VERSION=$(grep '^version = ' Cargo.toml | head -n1 | sed 's/version = "\(.*\)"/\1/')
            COMMIT_SHA=${GITHUB_SHA:0:7}
            BUILD_VERSION="${CARGO_VERSION}-${COMMIT_SHA}"
            echo "version=${BUILD_VERSION}" >> $GITHUB_OUTPUT
            echo "tag=v${BUILD_VERSION}" >> $GITHUB_OUTPUT
            echo "is_release=false" >> $GITHUB_OUTPUT
            echo "Development build - Version: ${BUILD_VERSION}"
          fi

  # Build job with matrix strategy for cross-platform compilation
  build:
    name: Build for ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: version
    strategy:
      fail-fast: false  # Don't cancel other builds if one fails
      matrix:
        include:
          # Linux x86_64
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            name: linux-x64
            cross: false
          
          # Linux ARM64 (cross-compile from x86_64)
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            name: linux-arm64
            cross: true
          
          # Windows x86_64
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            name: windows-x64
            cross: false
            extension: .exe
          
          # macOS x86_64
          - target: x86_64-apple-darwin
            os: macos-latest
            name: macos-x64
            cross: false
          
          # macOS ARM64 (Apple Silicon)
          - target: aarch64-apple-darwin
            os: macos-latest
            name: macos-arm64
            cross: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross (for cross-compilation)
        if: matrix.cross
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Configure Cargo for cross-compilation
        if: matrix.cross
        run: |
          echo "[target.${{ matrix.target }}]" >> ~/.cargo/config.toml
          echo "linker = \"aarch64-linux-gnu-gcc\"" >> ~/.cargo/config.toml
        shell: bash

      - name: Install cross-compilation dependencies (Linux ARM64)
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Build binary
        run: |
          if [ "${{ matrix.cross }}" = "true" ]; then
            cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
        shell: bash

      - name: Get binary name from Cargo.toml
        id: binary
        run: |
          BINARY_NAME=$(grep '^name = ' Cargo.toml | head -n1 | sed 's/name = "\(.*\)"/\1/')
          echo "name=${BINARY_NAME}" >> $GITHUB_OUTPUT
          echo "Binary name: ${BINARY_NAME}"
        shell: bash

      - name: Prepare binary for upload
        run: |
          BINARY_NAME="${{ steps.binary.outputs.name }}"
          TARGET_DIR="target/${{ matrix.target }}/release"
          BINARY_PATH="${TARGET_DIR}/${BINARY_NAME}${{ matrix.extension }}"
          
          # Create release directory
          mkdir -p release
          
          # Copy and rename binary with version and platform info
          RELEASE_NAME="${BINARY_NAME}-${{ needs.version.outputs.tag }}-${{ matrix.name }}${{ matrix.extension }}"
          cp "${BINARY_PATH}" "release/${RELEASE_NAME}"
          
          echo "RELEASE_NAME=${RELEASE_NAME}" >> $GITHUB_ENV
          echo "BINARY_PATH=release/${RELEASE_NAME}" >> $GITHUB_ENV
        shell: bash

      - name: Verify binary works
        run: |
          # Basic verification that the binary can execute
          if [ "${{ matrix.os }}" != "windows-latest" ]; then
            chmod +x "${{ env.BINARY_PATH }}"
            if ! "${{ env.BINARY_PATH }}" --help > /dev/null 2>&1 && ! "${{ env.BINARY_PATH }}" --version > /dev/null 2>&1; then
              echo "Warning: Binary verification failed, but continuing..."
            else
              echo "Binary verification successful"
            fi
          else
            # For Windows, just check if file exists and has reasonable size
            if [ -f "${{ env.BINARY_PATH }}" ]; then
              SIZE=$(stat -c%s "${{ env.BINARY_PATH }}" 2>/dev/null || stat -f%z "${{ env.BINARY_PATH }}" 2>/dev/null || echo "0")
              if [ "$SIZE" -gt 1000 ]; then
                echo "Binary verification successful (size: $SIZE bytes)"
              else
                echo "Warning: Binary seems too small"
              fi
            else
              echo "Error: Binary not found"
              exit 1
            fi
          fi
        shell: bash

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.name }}
          path: ${{ env.BINARY_PATH }}
          if-no-files-found: error

  # Release job that creates GitHub release with all binaries (only on tag builds)
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [version, build]
    # Only run this job when building from a tag that starts with 'v'
    if: needs.version.outputs.is_release == 'true'
    permissions:
      contents: write  # Required for creating releases
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          # Move all binaries to release-assets directory
          find artifacts -name "binary-*" -type d | while read dir; do
            find "$dir" -type f -exec mv {} release-assets/ \;
          done

  # Summary job for non-release builds (PRs, main branch pushes, manual dispatch)
  build_summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [version, build]
    # Only run when NOT creating a release
    if: needs.version.outputs.is_release == 'false'
    steps:
      - name: Download build artifacts for summary
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Build Summary
        run: |
          echo "## ✅ Build Verification Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** Development/Verification" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔧 Built Artifacts (Not Released):" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The following binaries were successfully built and verified:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if artifacts directory exists
          if [ -d "artifacts" ]; then
            # Process each platform's artifacts
            find artifacts -name "binary-*" -type d | sort | while read dir; do
              if [ -d "$dir" ]; then
                platform=$(basename "$dir" | sed 's/binary-//')
                echo "Processing $platform artifacts..." >&2
                
                # Find files in this platform directory
                find "$dir" -type f | while read file; do
                  if [ -f "$file" ]; then
                    filename=$(basename "$file")
                    size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "Unknown")
                    echo "- **$platform**: \`$filename\` ($size)" >> $GITHUB_STEP_SUMMARY
                  fi
                done
              fi
            done
          else
            echo "⚠️ No artifacts found - this may indicate a build failure." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "💡 **Note:** To create a release, push a tag starting with 'v' (e.g., \`git tag v1.0.0 && git push origin v1.0.0\`)" >> $GITHUB_STEP_SUMMARY
          
          echo "Release assets:"
          ls -la release-assets/

      - name: Check if release exists
        id: release_check
        run: |
          # Check if a release with this tag already exists
          if gh release view "${{ needs.version.outputs.tag }}" --repo "${{ github.repository }}" > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release ${{ needs.version.outputs.tag }} already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release ${{ needs.version.outputs.tag }} does not exist"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create or update release
        run: |
          if [ "${{ steps.release_check.outputs.exists }}" = "true" ]; then
            echo "Updating existing release..."
            gh release upload "${{ needs.version.outputs.tag }}" release-assets/* --clobber --repo "${{ github.repository }}"
          else
            echo "Creating new release..."
            
            # Generate release notes
            cat > release-notes.md << EOF
          # Release ${{ needs.version.outputs.tag }}
          
          ## 🚀 What's New
          
          Automated release of the Rust CLI application.
          
          ## 📦 Downloads
          
          Choose the appropriate binary for your platform:
          
          - **Linux x64**: \`*-linux-x64\`
          - **Linux ARM64**: \`*-linux-arm64\`
          - **Windows x64**: \`*-windows-x64.exe\`
          - **macOS x64**: \`*-macos-x64\`
          - **macOS ARM64** (Apple Silicon): \`*-macos-arm64\`
          
          ## 🔧 Installation
          
          1. Download the binary for your platform
          2. Make it executable (Unix systems): \`chmod +x <binary-name>\`
          3. Move to your PATH or run directly
          
          ## 📋 Build Information
          
          - **Commit**: ${{ github.sha }}
          - **Build Date**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          - **Rust Version**: $(rustc --version 2>/dev/null || echo "Unknown")
          EOF
            
            gh release create "${{ needs.version.outputs.tag }}" \
              --title "Release ${{ needs.version.outputs.tag }}" \
              --notes-file release-notes.md \
              --repo "${{ github.repository }}" \
              release-assets/*
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and Release Summary
        run: |
          echo "## 🎉 Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** Release" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release URL:** https://github.com/${{ github.repository }}/releases/tag/${{ needs.version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Released Artifacts:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -d "release-assets" ] && [ "$(ls -A release-assets/)" ]; then
            for file in release-assets/*; do
              if [ -f "$file" ]; then
                filename=$(basename "$file")
                size=$(ls -lh "$file" | awk '{print $5}')
                echo "- \`$filename\` ($size)" >> $GITHUB_STEP_SUMMARY
              fi
            done
          else
            echo "⚠️ No release assets found" >> $GITHUB_STEP_SUMMARY
          fi